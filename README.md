# 1. GitHub 주소

---

https://github.com/100-hours-a-week/2-jun-jang-KateBuCafeWithThread

# 2. 프로그램 소개

---

- 1주차 과제 설명
    
    ## 1. 사용자 이름 입력
    
    ```
    안녕하세요! 오늘부터 당신이 맡게 될 KaTeBu 카페입니다~
    당신의 이름을 알려주세요!
    ```
    
    ## 2. 규칙 설명
    
    ```
    <사용자 이름> 매니저님! 환영합니다~! 지금부터 간단한 규칙 알려드리겠습니다
    1. KaTeBu 카페 영업 시간은 9시부터 18시까지입니다.
    2. KaTeBu 카페는 프리미엄 카페라 1시간에 한 번 예약된 손님을 받습니다.
    3. 손님의 요구 사항에 맞춰 메뉴를 제공해 주세요.
    4. 잘못된 메뉴를 제공하면 손실액만큼 이익이 차감됩니다.
      4-1. 저희 손님들은 자부심이 높기 때문에 서비스를 준다면, 자신을 무시했다고 생각해, 돈을 내지 않습니다.
    5. 영업 종료 후 순이익이 마이너스면 해고되니 주의해주세요!
    6. 다음은 각 메뉴의 체크리스트입니다.
      6-1. 디저트는 포크의 개수를 요구사항에 맞게 정확히 드려야합니다
      6-2. 샌드위치는 길이, 그리고 케이크는 사이즈를 요구사항에 맞게 정확히 드려야합니다.
      6-3. 모든 음료는 HOT, ICE를 선택할 수 있으나, 에이드는 무조건 "ICE" 밖에 제공안되는 점 명시해주세요
      6-4. 커피는 원두 종류를 선택할 수 있습니다! 고객의 요구사항에 맞는 원두를 선택해주세요
      6-5. 에이드는 휘핑크림 여부를 선택할 수 있습니다!
    7. 그럼 화이팅해주세요!
    ```
    
    ## 3. 행동 선택
    
    ```
    --------------------------------------------------------------
    현재 시간: <현시간>     현재 이익: <이익>원     매니저: <사용자 이름>
    1. 손님 맞이하기
    2. 메뉴판 보기
    3. 규칙 보기
    4. 영업 종료하기
    --------------------------------------------------------------
    행동을 입력해주세요.
    ```
    
    ### 3-1. 손님 맞이하기 (손님의 주문은 랜덤 생성)
    
    ```
    --------------------------------------------------------------
    안녕하세요! 먼저 커피는 카페라테 로 주시고, HOT로 해주세요. 아 원두는 아라비아타로 해주시고 2잔 주세요. 
    그리고 자몽에이드 5잔 주세요. 휘핑크림은 빼고요! 
    그리고 케이크는 딸기 케이크로 사이즈는 medium로 포크는 3개 주시고요. 2개 주세요! 
    --------------------------------------------------------------
    손님이 원하는 메뉴를 골라주세요!
    ```
    
    ### 커피 선택지
    
    ```
    손님이 원하는 커피는 무엇인가요? (주문하지 않음을 선택하면 밑의 선택지 스킵)
    1. 아메리카노
    2. 카페라테
    3.주문하지 않음.
    --------------------------
    <선택지 입력>
    --------------------------
    ICE 인가요? HOT 인가요?
    1. ICE
    2. HOT
    --------------------------
    <선택지 입력>
    --------------------------
    원두 종류는 무엇인가요?
    1. 아라비아타
    2. 로부스타
    --------------------------
    <선택지 입력>
    --------------------------
    마지막으로 몇 잔 시키셨나요?
    --------------------------
    <선택지 입력>
    --------------------------
    ```
    
    ### 에이드 선택지
    
    ```
    손님이 원하는 에이드는 무엇인가요? (주문하지 않음을 선택하면 밑의 선택지 스킵)
    1. 레몬에이드
    2. 자몽에이드
    3. 주문하지 않음
    --------------------------
    <선택지 입력>
    --------------------------
    ICE 인가요? HOT 인가요?
    1. ICE
    2. HOT
    --------------------------
    <선택지 입력>
    --------------------------
    휘핑크림을 추가할까요? (1: 예, 2: 아니오)
    --------------------------
    <선택지 입력>
    --------------------------
    마지막으로 몇 잔 시키셨나요?
    --------------------------
    <선택지 입력>
    --------------------------
    ```
    
    ### 케이크 선택지
    
    ```
    손님이 원하는 케이크는 무엇인가요?(주문하지 않음을 선택하면 밑의 선택지 스킵)
    1. 딸기 케이크
    2. 초콜릿 케이크
    3. 주문하지 않음
    --------------------------
    <선택지 입력>
    --------------------------
    사이즈를 선택해주세요
    1. small
    2. medium
    3. large
    --------------------------
    <선택지 입력>
    --------------------------
    포크 개수를 입력해주세요.
    --------------------------
    <선택지 입력>
    --------------------------
    마지막으로 몇 개 시키셨나요?
    --------------------------
    <선택지 입력>
    --------------------------
    
    ```
    
    ### 샌드위치 선택지
    
    ```
    손님이 원하는 샌드위치는 무엇인가요? (주문하지 않음을 선택하면 밑의 선택지 스킵)
    1. 치킨 샌드위치
    2. 계란 샌드위치
    3. 주문하지 않음
    --------------------------
    <선택지 입력>
    --------------------------
    샌드위치 길이를 선택해주세요
    1. 15cm
    2. 30cm
    --------------------------
    <선택지 입력>
    --------------------------
    포크 개수를 입력해주세요.
    --------------------------
    <선택지 입력>
    --------------------------
    마지막으로 몇 개 시키셨나요?
    --------------------------
    <선택지 입력>
    --------------------------
    
    ```
    
    ### 결과
    
    ```
    #실패시
    --------------------------------------------------------------
    손님이 주문하신 것
    커피 : 아메리카노
       - 온도 : HOT
       - 커피 원두 : 로부스타
       - 수량 : 3잔
    에이드 : 자몽에이드
       - 휘핑크림 여부 : 포함
       - 수량 : 5잔
    샌드위치 : 계란 샌드위치
       - 길이 : 15Cm
       - 포크 개수 : 2개
       - 수량 : 5개
    --------------------------------------------------------------
    매니저님이 선택하신 것
    커피 : 아메리카노
       - 온도 : ICE
       - 커피 원두 : 아라비아타
       - 수량 : 1잔
    에이드 : 레몬에이드
       - 휘핑크림 여부 : 포함
       - 수량 : 1잔
    케이크 : 딸기 케이크
       - 사이즈 : small
       - 포크 개수 : 1개
       - 수량 : 1개
    케이크 : 치킨 샌드위치
       - 길이 : 15Cm
       - 포크 개수 : 1개
       - 수량 : 1개
    --------------------------------------------------------------
    결과 : 실패..
    손님 : 제가 주문한게 아닌데요? 환불해주세요!
    --------------------------------------------------------------
    
    #성공시
    --------------------------------------------------------------
    손님이 주문하신 것
    커피 : 아메리카노
       - 온도 : HOT
       - 커피 원두 : 로부스타
       - 수량 : 3잔
    에이드 : 자몽에이드
       - 휘핑크림 여부 : 포함
       - 수량 : 5잔
    샌드위치 : 계란 샌드위치
       - 길이 : 15Cm
       - 포크 개수 : 2개
       - 수량 : 5개
    --------------------------------------------------------------
    매니저님이 선택하신 것
    커피 : 아메리카노
       - 온도 : HOT
       - 커피 원두 : 로부스타
       - 수량 : 3잔
    에이드 : 자몽에이드
       - 휘핑크림 여부 : 포함
       - 수량 : 5잔
    케이크 : 계란 샌드위치
       - 길이 : 15Cm
       - 포크 개수 : 2개
       - 수량 : 5개
    --------------------------------------------------------------
    결과 : 성공!
    손님 : 감사합니다! 좋은 하루되세요~
    --------------------------------------------------------------
    ```
    
    ### 3-2. 메뉴판 보기
    
    ```
    메뉴판:
    1. 샌드위치 - 치킨 샌드위치, 계란 샌드위치 - 5,000 원 
    2. 케이크 - 생크림 케이크, 초콜릿 케이크 - 7,000 원
    3. 커피 - 아메리카노, 에스프레소 - 3,000 원
    4. 에이드 - 레몬에이드, 자몽에이드 - 4,000 원
    ```
    
    ### 3-3. 규칙 보기
    
    ```
    1. KaTeBu 카페 영업 시간은 9시부터 18시까지입니다.
    2. KaTeBu 카페는 프리미엄 카페라 1시간에 한 번 예약된 손님을 받습니다.
    3. 손님의 요구 사항에 맞춰 메뉴를 제공해 주세요.
    4. 잘못된 메뉴를 제공하면 손실액만큼 이익이 차감됩니다.
      4-1. 저희 손님들은 자부심이 높기 때문에 서비스를 준다면, 자신을 무시했다고 생각해, 돈을 내지 않습니다.
    5. 영업 종료 후 순이익이 마이너스면 해고되니 주의해주세요!
    6. 다음은 각 메뉴의 체크리스트입니다.
      6-1. 디저트는 포크의 개수를 요구사항에 맞게 정확히 드려야합니다
      6-2. 샌드위치는 길이, 그리고 케이크는 사이즈를 요구사항에 맞게 정확히 드려야합니다.
      6-3. 모든 음료는 HOT, ICE를 선택할 수 있으나, 에이드는 무조건 "ICE" 밖에 제공안되는 점 명시해주세요
      6-4. 커피는 원두 종류를 선택할 수 있습니다! 고객의 요구사항에 맞는 원두를 선택해주세요
      6-5. 에이드는 휘핑크림 여부를 선택할 수 있습니다!
    7. 그럼 화이팅해주세요!
    ```
    
    ### 3-4. 영업 종료하기
    
    ```
    
    #실패시
    
    영업을 종료합니다. 최종 이익: <이익 < 0> 원
    해고되었습니다...
    
    #성공시
    
    영업을 종료합니다. 최종 이익: <이익 > 0>원
    오늘 하루도 수고하셨습니다!
    ```
    

## 추가 설명

---

> “KaTeBu 카페 매니저를 맡게 된지도, 얼마나 시간이 지났을까.. 당신은 진상손님들때문에 스트레스를 받고 있습니다.. 이때 떠오르는 좋은 생각..! 진상손님들을 무찌르면 행복해지지 않을까요?
이제부터 진상손님이 나타나면 당신은 진상손님과 싸웁니다…! 
이기면 진상 손님에게서 추가 보상을 얻고, 지면 손해 보상금을 내야하는 지금! 
당신은 해고당하지 않고 평화로운 KaTeBu 매니저 생활을 계속할 수 있을까요?
> 
- 진상 손님이 나타난 상황(40% 확률)

```
평화로운 영업시간! 진상 손님이 등장했습니다!
진상손님 : 이거 환불해!
전투 시작!
--------------------------------------------------------------
<매니저이름> 매니저이(가) 진상손님을(를) 빚맞췄습니다! 
진상손님이(가) <매니저이름> 매니저을(를) 공격합니다! (공격력: 40)
<매니저이름>매니저이(가) 40의 피해를 입었습니다. 남은 체력: 60
<매니저이름> 매니저이(가) 진상손님을(를) 빚맞췄습니다! 
진상손님이(가) <매니저이름> 매니저을(를) 공격합니다! (공격력: 40)
<매니저이름>매니저이(가) 40의 피해를 입었습니다. 남은 체력: 20
<매니저이름> 매니저이(가) 진상손님을(를) 공격합니다! (공격력: 40)
진상손님이(가) 40의 피해를 입었습니다. 남은 체력: 40
진상손님이(가) <매니저이름> 매니저을(를) 빚맞췄습니다! 
<매니저이름> 매니저이(가) 진상손님을(를) 공격합니다! (공격력: 40)
진상손님이(가) 40의 피해를 입었습니다. 남은 체력: 0
--------------------------------------------------------------
//승리 시
매니저 승리! 진상을 해치웠습니다!
진상 손님의 주머니를 뒤져 10,000원을 획득했습니다!
--------------------------------------------------------------
//패배 시
진상 손님이 승리.. 매니저가 패배했습니다.
진상 손님에게 피해 보상금으로 5,000원을 지불했습니다..
--------------------------------------------------------------
```

# 영상 첨부

---

https://youtu.be/xO9WrxoAUrU

# 2주차 새롭게 개선한 부분

---

- 프로그램 구조
    
    ```
    ├── Model
    │   └── Character// 새로 추가된 패키지와 클래스
    │       └── Character.class(java) //진상손님과 매니저의 클래스의 부모 클래스
    │       └── JinsangCustomer.class(java)
    │       └── Manager.class(java)
    │   └── Customer // ex.auth
    │       └── Customer.class(java)
    │   └── Food
    │       └── Dessert
    │           └── Dessert.class(java)
    │           └── Cake.class(java)
    │           └── Sandwich.class(java)
    │       └── Drink
    │           └── Drink.class(java)
    │           └── Coffee.class(java)
    │           └── Ade.class(java)
    │       └── Food.class(java)
    │   └── Enums
    │       └── Menu
    │       └── CoffeeBeans
    │       └── DrinkTemperature
    │       └── CakeSizes
    │       └── SandwichLength
    ├── Service
    │   └── Game.class(java)
    │   //싸움 비즈니스 로직을 관리하는 스레드
    │   └── FightTask.class(java)
    ├── Utill
    │   //싸움 전체적인 로직을 관리해주는 util
    │   └── FightManager.class(java)
    │   └── InputHandler.class(java)
    │   └── MenuFactory.class(java)
    Main.class
    ```
    
    - 싸움과 관련된 속성들을 가지고 있는 **Character 클래스**와 그 하위 클래스로 **JinSangCustomer와 Manager 클래스를 정의**했습니다.
    - 싸움 (때리고 막는) 기능을 구현하기 위한 스레드를 **FightTask 클래스에서 구현**했습니다.
    - 싸움의 전체적인 로직(전투의 전체적인 흐름)을 관리하기 위해 **FightManager 클래스를 구현**했습니다.
    
    ### 주요 로직
    
    ---
    
    ```
    package Service;
    
    import Model.Character.Character;
    
    public class FightTask implements Runnable {
    
        private final Character attacker;
        private final Character defender;
        private final Object lock;
        public FightTask(Character attacker, Character defender,Object lock) {
            this.attacker = attacker;
            this.defender = defender;
            this.lock = lock;
        }
        @Override
        public void run() {
            while (attacker.isAlive() && defender.isAlive()) {
                //동시에 두개의 스레드가 한 캐릭터를 동시에 공격하는걸 방지
                synchronized (lock) {
                    attacker.attack(defender);
                    if(!defender.isAlive()) {
                        //상대가 쓰려졌으면 전투 종료
                        lock.notifyAll();
                        break;
                    }
                    try{
                        //한번 때렸으니, 공격 기회를 넘김
                        lock.notify();;
                        lock.wait();
    
                    }catch(InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                try {
                    Thread.sleep(1000); // 공격 딜레이
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
    
    ```
    
    - **Runnable 인터페이스를 이용해 쓰레드 로직을 구성**했습니다.
    - **서로 공격자 방어자가 한번씩 번갈아가며, 공격 해야하기 때문**에 **lock**을 걸고, **Wait 과 Notify를 활용하여, 순서를 보장하도록 구현**했습니다.
    - **lock은 notify()와 wait() 메서드가 있는 Object 객체로 선언**했습니다.

### synchronized (this) vs synchronized (Object) ?

---

```
public class FightTask implements Runnable {

    private Character attacker;
    private Character defender;
    public FightTask(Character attacker, Character defender) {
        this.attacker = attacker;
        this.defender = defender;
    }
    @Override
    public void run() {
        while (attacker.isAlive() && defender.isAlive()) {
            //동시에 두개의 스레드가 한 캐릭터를 동시에 공격하는걸 방지
            synchronized (this) {
                if (attacker.isAlive() && defender.isAlive()) {
                    attacker.attack(defender);
                }
            }
            try {
                Thread.sleep(1000); // 공격 딜레이
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

- 처음엔 **this를 이용해 해당 객체 자체에  synchronized 키워드를 이용해 객체 자체를 락으로 사용**하여 동기화를 수행하려 했습니다.
- 하지만 출력 결과를 보니

```
행동을 입력해주세요.
1
평화로운 영업시간! 진상 손님이 등장했습니다!
전투 시작!
진상손님이(가) 매니저을(를) 공격합니다! (공격력: 40)
매니저이(가) 진상손님을(를) 공격합니다! (공격력: 40)
매니저이(가) 방어에 성공했습니다! 데미지를 절반만 맞습니다. 남은 체력: 80
진상손님이(가) 40의 피해를 입었습니다. 남은 체력: 40
진상손님이(가) 매니저을(를) 공격합니다! (공격력: 40)
매니저이(가) 40의 피해를 입었습니다. 남은 체력: 40
매니저이(가) 진상손님을(를) 빚맞췄습니다! 
진상손님이(가) 매니저을(를) 공격합니다! (공격력: 40)
매니저이(가) 방어에 성공했습니다! 데미지를 절반만 맞습니다. 남은 체력: 20
매니저이(가) 진상손님을(를) 공격합니다! (공격력: 40)
진상손님이(가) 방어에 성공했습니다! 데미지를 절반만 맞습니다. 남은 체력: 20
진상손님이(가) 매니저을(를) 공격합니다! (공격력: 40)
매니저이(가) 40의 피해를 입었습니다. 남은 체력: 0
진상 손님이 승리.. 매니저가 패배했습니다.
```

- 해당 결과처럼 전혀 순서가 동일하지 않고, 예상과 다른 결과가 나왔습니다.
- 원인을 파악하니 제가 놓친 부분이 있었습니다.

```
   public boolean startFight() throws InterruptedException {
        System.out.println("진상손님 : "+jinsangCustomer.getComplaint().getName());
        System.out.println("전투 시작!");
        System.out.println("--------------------------------------------------------------");
        Thread.sleep(1000);
        FightTask managerAttack=new FightTask(manager,jinsangCustomer);
        FightTask jinsangCustomerAttack=new FightTask(jinsangCustomer,manager);

        Thread managerThread = new Thread(managerAttack);
        Thread jinsangThread = new Thread(jinsangCustomerAttack);

        managerThread.start();
        jinsangThread.start();

        managerThread.join();
        jinsangThread.join();

        return endFight();
    }
```

- 해당 코드와 같이, FightTask(Thread) 인스턴스를 하나만 생성하는 것이 아니라, 각 캐릭터들(매니저와 진상 손님) 에 관하여, FightTask(Thread) 객체를 **개별적으로 생성**하기 때문에, 각 **인스턴스들은 서로 다른 락을 사용**합니다.
- 하지만 저는 코드를 작성할 당시 **이 부분을 전혀 생각하지 않았었고** 그렇기에 이와 같은 결과가 나왔습니다.

```
package Service;

import Model.Character.Character;

public class FightTask implements Runnable {

    private final Character attacker;
    private final Character defender;
    private final Object lock;
    public FightTask(Character attacker, Character defender,Object lock) {
        this.attacker = attacker;
        this.defender = defender;
        this.lock = lock;
    }
    @Override
    public void run() {
        while (attacker.isAlive() && defender.isAlive()) {
            //동시에 두개의 스레드가 한 캐릭터를 동시에 공격하는걸 방지
            synchronized (lock) {
                attacker.attack(defender);
                if(!defender.isAlive()) {
                    //상대가 쓰려졌으면 전투 종료
                    lock.notifyAll();
                    break;
                }
                try{
                    //한번 때렸으니, 공격 기회를 넘김
                    lock.notify();;
                    lock.wait();

                }catch(InterruptedException e) {
                    e.printStackTrace();
                }
            }
            try {
                Thread.sleep(1000); // 공격 딜레이
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

```

- 그렇기 때문에 두 FightTask(Thread)객체에 lock 객체를 공유해서 동기화를 시켜줬습니다.
- 또한 Wait() 과 Notify()를 이용해, 턴 기반으로 보이도록 구현했고, 예상과 같이 의도된 순서가 등장했습니다.

### 느낀 점

---

- 이로 인해 느낀점은, 쓰레드, 락 과 같은 이론을 직접 녹여 볼때는 그 방법이 적절한지, 그 방법으로 인해 내가 얻는 이점은 무엇이고 단점은 무엇인지, 더 나은 방향은 있는지 지속적으로 체크해야겠다고 다짐했습니다.